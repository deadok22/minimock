package minimock

const (
	// HeaderTemplate is used to generate package clause and go:generate instruction
	HeaderTemplate = `
		package {{$.Package.Name}}

		// Code generated by http://github.com/gojuno/minimock ({{$.Options.HeaderVars.Version}}). DO NOT EDIT.

		{{if $.Options.HeaderVars.GenerateInstruction}}
		//go:generate minimock -i {{$.SourcePackage.PkgPath}}.{{$.Options.InterfaceName}} -o {{$.Options.OutputFile}}
		{{end}}

		import (
			{{range $import := $.Options.Imports}}{{- if not (in $import "\"time\"" "\"sync/atomic\"" "\"github.com/gojuno/minimock\"")}}
				{{$import}}{{end}}{{end}}
			{{$.Options.SourcePackageAlias}} "{{$.SourcePackage.PkgPath}}"
			mm_reflect "reflect"
			mm_atomic "sync/atomic"
			mm_time "time"
			mm_params "github.com/gojuno/minimock/internal/params"
			"github.com/gojuno/minimock"
		)
	`

	// BodyTemplate is used to generate mock body
	BodyTemplate = `
		{{ $mock := (title (printf "%sMock" $.Interface.Name)) }}
		{{ $mockArgs := (printf "m%sMockArgs" $.Interface.Name) }}

		// {{$mock}} implements {{$.Interface.Type}}
		type {{$mock}} struct {
			t minimock.Tester
			{{ range $method := $.Interface.Methods }}
				func{{$method.Name}} func{{ $method.Signature }}
				after{{$method.Name}}Counter uint64
				before{{$method.Name}}Counter uint64
				{{$method.Name}}Mock m{{$mock}}{{$method.Name}}
			{{ end }}
			MinimockArg {{$mockArgs}}
		}

		// New{{$mock}} returns a mock for {{$.Interface.Type}}
		func New{{$mock}}(t minimock.Tester) *{{$mock}} {
			m := &{{$mock}}{t: t}
			if controller, ok := t.(minimock.MockController); ok {
				controller.RegisterMocker(m)
			}
			{{ range $method := $.Interface.Methods }}
				m.{{$method.Name}}Mock = m{{$mock}}{{$method.Name}}{mock: m}
				{{ if $method.HasParams }} m.{{$method.Name}}Mock.callArgs = []*{{$mock}}{{$method.Name}}Params{} {{ end }}
			{{ end }}
			return m
		}

		type {{$mockArgs}} struct {
			matchers mm_params.Matchers
		}

		{{ range $ptype := (distinctParameterTypeNames $.Interface.Methods) }}
			func (m *{{$mockArgs}}) Matched{{(identifierFromType $ptype)}}(matches func({{$ptype}}) bool) (z {{$ptype}}) {
				m.matchers.AddMatchFunc(matches)
				return z
			}
		{{ end }}

		{{ range $method := $.Interface.Methods }}
			{{ $m := (printf "mm%s" $method.Name) }}

			type m{{$mock}}{{$method.Name}} struct {
				mock              *{{$mock}}
				defaultExpectation   *{{$mock}}{{$method.Name}}Expectation
				expectations []*{{$mock}}{{$method.Name}}Expectation
				{{ if $method.HasParams }}
					callArgs []*{{$mock}}{{$method.Name}}Params
					mutex sync.RWMutex
				{{ end }}
			}

			// {{$mock}}{{$method.Name}}Expectation specifies expectation struct of the {{$.Interface.Name}}.{{$method.Name}}
			type {{$mock}}{{$method.Name}}Expectation struct {
				mock *{{$mock}}
				{{ if $method.HasParams }} params *{{$mock}}{{$method.Name}}Params
					matchers *{{$mock}}{{$method.Name}}Matchers {{end}}
				{{ if $method.HasResults }} results *{{$mock}}{{$method.Name}}Results {{end}}
				Counter uint64
			}

			{{if $method.HasParams }}
				// {{$mock}}{{$method.Name}}Params contains parameters of the {{$.Interface.Name}}.{{$method.Name}}
				type {{$mock}}{{$method.Name}}Params {{$method.ParamsStruct}}

				type {{$mock}}{{$method.Name}}Matchers struct {
					{{ range $p := $method.Params }} 
						{{$p.Name}} func({{$p.Type}}) bool{{ end }}
				}
			{{end}}

			{{if $method.HasResults }}
				// {{$mock}}{{$method.Name}}Results contains results of the {{$.Interface.Name}}.{{$method.Name}}
				type {{$mock}}{{$method.Name}}Results {{$method.ResultsStruct}}
			{{end}}

			// Expect sets up expected params for {{$.Interface.Name}}.{{$method.Name}}
			func ({{$m}} *m{{$mock}}{{$method.Name}}) Expect({{$method.Params}}) *m{{$mock}}{{$method.Name}} {
				if {{$m}}.mock.func{{$method.Name}} != nil {
					{{$m}}.mock.t.Fatalf("{{$mock}}.{{$method.Name}} mock is already set by Set")
				}

				if {{$m}}.defaultExpectation == nil {
					{{$m}}.defaultExpectation = &{{$mock}}{{$method.Name}}Expectation{}
				}

				{{if $method.HasParams }}
					{{$m}}.defaultExpectation.params = &{{$mock}}{{$method.Name}}Params{ {{ $method.ParamsNames }} }
					for _, e := range {{$m}}.expectations {
						if minimock.Equal(e.params, {{$m}}.defaultExpectation.params) {
							{{$m}}.mock.t.Fatalf("Expectation set by When has same params: %#v", *{{$m}}.defaultExpectation.params)
						}
					}
				{{end}}
				return {{$m}}
			}

			// Return sets up results that will be returned by {{$.Interface.Name}}.{{$method.Name}}
			func ({{$m}} *m{{$mock}}{{$method.Name}}) Return({{$method.Results}}) *{{$mock}} {
				if {{$m}}.mock.func{{$method.Name}} != nil {
					{{$m}}.mock.t.Fatalf("{{$mock}}.{{$method.Name}} mock is already set by Set")
				}

				if {{$m}}.defaultExpectation == nil {
					{{$m}}.defaultExpectation = &{{$mock}}{{$method.Name}}Expectation{mock: {{$m}}.mock}
				}
				{{if $method.HasResults }} {{$m}}.defaultExpectation.results = &{{$mock}}{{$method.Name}}Results{ {{ $method.ResultsNames }} } {{end}}
				return {{$m}}.mock
			}

			//Set uses given function f to mock the {{$.Interface.Name}}.{{$method.Name}} method
			func ({{$m}} *m{{$mock}}{{$method.Name}}) Set(f func{{$method.Signature}}) *{{$mock}}{
				if {{$m}}.defaultExpectation != nil {
					{{$m}}.mock.t.Fatalf("Default expectation is already set for the {{$.Interface.Name}}.{{$method.Name}} method")
				}

				if len({{$m}}.expectations) > 0 {
					{{$m}}.mock.t.Fatalf("Some expectations are already set for the {{$.Interface.Name}}.{{$method.Name}} method")
				}

				{{$m}}.mock.func{{$method.Name}}= f
				return {{$m}}.mock
			}

			{{if (and $method.HasParams $method.HasResults)}}
				// When sets expectation for the {{$.Interface.Name}}.{{$method.Name}} which will trigger the result defined by the following
				// Then helper
				func ({{$m}} *m{{$mock}}{{$method.Name}}) When({{$method.Params}}) *{{$mock}}{{$method.Name}}Expectation {
					if {{$m}}.mock.func{{$method.Name}} != nil {
						{{$m}}.mock.t.Fatalf("{{$mock}}.{{$method.Name}} mock is already set by Set")
					}
					mm_m, mm_e := &{{$mock}}{{$method.Name}}Matchers{}, &{{$mock}}{{$method.Name}}Params{}
					{{$m}}.mock.MinimockArg.matchers.Expectation({{$m}}.mock.t, "{{$mock}}.{{$method.Name}}").
					{{range $p := $method.Params}}Next({{$p.Name}}, &mm_m.{{$p.Name}}, &mm_e.{{$p.Name}}).
					{{end}}
					Done()
					mm_me := &{{$mock}}{{$method.Name}}Expectation{mock: {{$m}}.mock, params: mm_e, matchers: mm_m}
					{{$m}}.expectations = append({{$m}}.expectations, mm_me)
					return mm_me
				}

				// Then sets up {{$.Interface.Name}}.{{$method.Name}} return parameters for the expectation previously defined by the When method
				func (e *{{$mock}}{{$method.Name}}Expectation) Then({{$method.Results}}) *{{$mock}} {
					e.results = &{{$mock}}{{$method.Name}}Results{ {{ $method.ResultsNames }} }
					return e.mock
				}
			{{end}}

			// {{$method.Name}} implements {{$.Interface.Type}}
			func ({{$m}} *{{$mock}}) {{$method.Declaration}} {
				mm_atomic.AddUint64(&{{$m}}.before{{$method.Name}}Counter, 1)
				defer mm_atomic.AddUint64(&{{$m}}.after{{$method.Name}}Counter, 1)

				{{if $method.HasParams}}
					params := &{{$mock}}{{$method.Name}}Params{ {{$method.ParamsNames}} }

					// Record call args
					{{$m}}.{{$method.Name}}Mock.mutex.Lock()
				{{$m}}	.{{$method.Name}}Mock.callArgs = append({{$m}}.{{$method.Name}}Mock.callArgs, params)
					{{$m}}.{{$method.Name}}Mock.mutex.Unlock()

					for _, e := range {{$m}}.{{$method.Name}}Mock.expectations {
						if true {{range $p := $method.Params}}&& (e.matchers.{{$p.Name}} != nil && e.matchers.{{$p.Name}}({{$p.Name}}) || e.matchers.{{$p.Name}} == nil && minimock.Equal(e.params.{{$p.Name}}, {{$p.Name}})) {{end}}{
							mm_atomic.AddUint64(&e.Counter, 1)
							{{$method.ReturnStruct "e.results" -}}
						}
					}
				{{end}}

				if {{$m}}.{{$method.Name}}Mock.defaultExpectation != nil {
					mm_atomic.AddUint64(&{{$m}}.{{$method.Name}}Mock.defaultExpectation.Counter, 1)
					{{- if $method.HasParams }}
						want := {{$m}}.{{$method.Name}}Mock.defaultExpectation.params
						got := {{$mock}}{{$method.Name}}Params{ {{$method.ParamsNames}} }
						if want != nil && !minimock.Equal(*want, got) {
							{{$m}}.t.Errorf("{{$mock}}.{{$method.Name}} got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
						}
					{{ end }}
					{{if $method.HasResults }}
						results := {{$m}}.{{$method.Name}}Mock.defaultExpectation.results
						if results == nil {
							{{$m}}.t.Fatal("No results are set for the {{$mock}}.{{$method.Name}}")
						}
						{{$method.ReturnStruct "(*results)" -}}
					{{else}}
						return
					{{ end }}
				}
				if {{$m}}.func{{$method.Name}} != nil {
					{{$method.Pass (printf "%s.func" $m)}}
				}
				{{$m}}.t.Fatalf("Unexpected call to {{$mock}}.{{$method.Name}}.{{range $method.Params}} %v{{end}}", {{ $method.ParamsNames }} )
				{{if $method.HasResults}}return{{end}}
			}

			// {{$method.Name}}AfterCounter returns a count of finished {{$mock}}.{{$method.Name}} invocations
			func ({{$m}} *{{$mock}}) {{$method.Name}}AfterCounter() uint64 {
				return mm_atomic.LoadUint64(&{{$m}}.after{{$method.Name}}Counter)
			}

			// {{$method.Name}}BeforeCounter returns a count of {{$mock}}.{{$method.Name}} invocations
			func ({{$m}} *{{$mock}}) {{$method.Name}}BeforeCounter() uint64 {
				return mm_atomic.LoadUint64(&{{$m}}.before{{$method.Name}}Counter)
			}

			{{ if $method.HasParams }}
				// Calls returns a list of arguments used in each call to {{$mock}}.{{$method.Name}}.
				// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
				func ({{$m}} *m{{$mock}}{{$method.Name}}) Calls() []*{{$mock}}{{$method.Name}}Params {
					{{$m}}.mutex.RLock()

					argCopy := make([]*{{$mock}}{{$method.Name}}Params, len({{$m}}.callArgs))
					copy(argCopy, {{$m}}.callArgs)

					{{$m}}.mutex.RUnlock()

					return argCopy
				}
			{{ end }}

			// Minimock{{$method.Name}}Done returns true if the count of the {{$method.Name}} invocations corresponds
			// the number of defined expectations
			func (m *{{$mock}}) Minimock{{$method.Name}}Done() bool {
				for _, e := range m.{{$method.Name}}Mock.expectations {
					if mm_atomic.LoadUint64(&e.Counter) < 1 {
						return false
					}
				}

				// if default expectation was set then invocations count should be greater than zero
				if m.{{$method.Name}}Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.after{{$method.Name}}Counter) < 1 {
					return false
				}
				// if func was set then invocations count should be greater than zero
				if m.func{{$method.Name}} != nil && mm_atomic.LoadUint64(&m.after{{$method.Name}}Counter) < 1  {
					return false
				}
				return true
			}

			// Minimock{{$method.Name}}Inspect logs each unmet expectation
			func (m *{{$mock}}) Minimock{{$method.Name}}Inspect() {
				for _, e := range m.{{$method.Name}}Mock.expectations {
					if mm_atomic.LoadUint64(&e.Counter) < 1 {
						{{- if $method.HasParams}}
							m.t.Errorf("Expected call to {{$mock}}.{{$method.Name}} with params: %#v", *e.params)
						{{else}}
							m.t.Error("Expected call to {{$mock}}.{{$method.Name}}")
						{{end -}}
					}
				}

				// if default expectation was set then invocations count should be greater than zero
				if m.{{$method.Name}}Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.after{{$method.Name}}Counter) < 1 {
					{{- if $method.HasParams}}
						if m.{{$method.Name}}Mock.defaultExpectation.params == nil {
							m.t.Error("Expected call to {{$mock}}.{{$method.Name}}")
						} else {
							m.t.Errorf("Expected call to {{$mock}}.{{$method.Name}} with params: %#v", *m.{{$method.Name}}Mock.defaultExpectation.params)
						}
					{{else}}
						m.t.Error("Expected call to {{$mock}}.{{$method.Name}}")
					{{end -}}
				}
				// if func was set then invocations count should be greater than zero
				if m.func{{$method.Name}} != nil && mm_atomic.LoadUint64(&m.after{{$method.Name}}Counter) < 1  {
					m.t.Error("Expected call to {{$mock}}.{{$method.Name}}")
				}
			}
		{{end}}

		// MinimockFinish checks that all mocked methods have been called the expected number of times
		func (m *{{$mock}}) MinimockFinish() {
			if !m.minimockDone() {
				{{- range $method := $.Interface.Methods }}
					m.Minimock{{$method.Name}}Inspect()
				{{ end -}}
				m.t.FailNow()
			}
		}

		// MinimockWait waits for all mocked methods to be called the expected number of times
		func (m *{{$mock}}) MinimockWait(timeout mm_time.Duration) {
			timeoutCh := mm_time.After(timeout)
			for {
				if m.minimockDone() {
					return
				}
				select {
				case <-timeoutCh:
					m.MinimockFinish()
					return
				case <-mm_time.After(10 * mm_time.Millisecond):
				}
			}
		}

		func (m *{{$mock}}) minimockDone() bool {
			done := true
			return done {{ range $method := $.Interface.Methods }}&&
			m.Minimock{{$method.Name}}Done(){{end -}}
		}
	`
)
